{"version":3,"file":"tag-parser.es.js","sources":["../src/utils/assign.js","../src/skip-regex.js","../src/extract-expr.js","../src/parser.js"],"sourcesContent":["/*\n  This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway.\n*/\nif (typeof Object.assign != 'function') {\n  Object.defineProperty(Object, 'assign', {\n    configurable: true,\n    writable: true,\n    value: function (dest) {\n      if (dest == null) {\n        throw new TypeError('Cannot convert dest to object')\n      }\n      var arg = arguments\n\n      dest = Object(dest)\n      for (var ix = 1; ix < arg.length; ix++) {\n        var src = arg[ix]\n        if (src != null) {\n          var k, key, keys = Object.keys(Object(src))\n          for (k = 0; k < keys.length; k++) {\n            key = keys[k]\n            dest[key] = src[key]\n          }\n        }\n      }\n      return dest\n    }\n  })\n}\n\nexport default Object.assign\n","\n// safe characters to precced a regex (including `=>`, `**`, and `...`)\nconst beforeReChars = '[{(,;:?=|&!^~>%*/'\n\n// keyword that can preceed a regex (`in` is handled as special case)\n// Makes no sense to include delete, instanceof, extends, new, throw.\nconst beforeReWords = [\n  'case',\n  'default',\n  'do',\n  'else',\n  'in',\n  'return',\n  'typeof',\n  'void',\n  'yield'\n]\n\n// Pre-testing the keywords can speedup the search about 30%\nconst wordsLastChar = beforeReWords.reduce((s, w) => s + w.slice(-1), '')\n\n// The regexes can't include line-endings\nconst RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/\n\n// Valid characters for JavaScript identifiers and literal numbers\nconst RE_VN_CHAR = /[$\\w]/\n\n// Searches the position of the previous non-blank character inside `code`,\n// starting with `pos - 1`.\nfunction prev(code, pos) {\n  while (--pos >= 0 && /\\s/.test(code[pos]));\n  return pos\n}\n\n/**\n * Check if the code in the `start` position can be a regex.\n *\n * @param   {string} code  - Buffer to test in\n * @param   {number} start - Position following the slash inside `code`\n * @returns {number} `true` if the slash can start a regex.\n */\nexport default function skipRegex(code, start) {\n\n  // `exec()` will extract from the slash to the end of line and the\n  // chained `match()` will match the possible regex.\n  const re = /.*/g\n  let pos = re.lastIndex = start - 1\n  const match = re.exec(code)[0].match(RE_REGEX)\n\n  if (match) {\n    const next = pos + match[0].length  // result comes from `match()`\n\n    pos = prev(code, pos)\n    const c = code[pos]\n\n    // start of buffer or safe prefix?\n    if (pos < 0 || ~beforeReChars.indexOf(c)) {\n      return next\n    }\n\n    // from here, `pos` is >= 0 and `c` is code[pos]\n    // altough match[0] looks like a regex, we need to double-check this\n    if (c === '.') {\n      // can be `...` or something silly like 5./2\n      if (code[pos - 1] === '.') {\n        start = next\n      }\n\n    } else if (c === '+' || c === '-') {\n      // tricky case\n      if (code[--pos] !== c ||              // if have a single operator or\n          (pos = prev(code, pos)) < 0 ||    // ...have `++` and no previous token or\n          !RE_VN_CHAR.test(code[pos])) {    // ...the token is not a JS var/number\n        start = next                        // ...this is a regex\n      }\n\n    } else if (~wordsLastChar.indexOf(c)) {\n      // keyword?\n      const end = pos + 1\n\n      // get the preceding keyword, if this is in out list we have a regex\n      while (--pos >= 0 && RE_VN_CHAR.test(code[pos]));\n      if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n        start = next\n      }\n    }\n  }\n\n  return start\n}\n","/**\n * Mini-parser for expressions.\n * The main pourpose of this module is to find the end of an expression\n * and return its text without the enclosing brackets.\n * Does not works with comments, but supports ES6 template strings.\n * @module exprExtractor\n */\n\nimport skipRegex from './skip-regex'\n\n/*\n  If closing brace is }, ], ) we need find the open braces first,\n  to discard others that belongs to JavaScript objects.\n  Example of closing brackets:\n  `}}`, `})`\n*/\n\n// Matches double quoted JS strings taking care about nested quotes\n// and EOLs (escaped eols are Ok).\nconst S_SQ_STR = /'[^'\\n\\r\\\\]*(?:\\\\(?:\\r\\n?|[\\S\\s])[^'\\n\\r\\\\]*)*'/.source\nconst S_STRING = `${S_SQ_STR}|${S_SQ_STR.replace(/'/g, '\"')}`\n\n\n/**\n * Parses the code string searching the end of the expression.\n * @param {object} options - Parser parameters\n * @class ExprExtractor\n */\nfunction ExprExtractor(options) {\n  this._bp   = options.brackets             // brackets pair\n  this._re   = new RegExp(`${S_STRING}|${this._reChar(this._bp[1])}`, 'g')\n  this.parse = this.parse.bind(this)\n}\n\n\nExprExtractor.prototype = {\n\n  /**\n   * Parses the code string searching the end of the expression.\n   * It skips braces, quoted strings, regexes, and ES6 template literals.\n   *\n   * @param   {string} code  - Buffer to parse\n   * @param   {number} start - Position of the opening brace\n   * @returns {number} Expression's end (after the closing brace) or -1 if it is not an expr.\n   */\n  parse(code, start) {  //eslint-disable-line complexity\n    const bp = this._bp\n    const re = this._re\n\n    // Escaped brackets like \"\\{\" must be converted by the builder to literal brackets.\n    if (code[start - 1] === '\\\\') {\n      return bp[0]\n    }\n\n    const closingStr = bp[1]\n    const offset = start + bp[0].length\n    const stack = []                        // braces (or 1, for ES6 TL)\n\n    let match, ch\n\n    re.lastIndex = offset                   // skip first brace\n\n    while ((match = re.exec(code))) {\n      const end = re.lastIndex\n      let str = match[0]\n\n      if (str === closingStr) {\n        if (!stack.length) {\n          return {\n            text: code.slice(offset, match.index),\n            start,\n            end\n          }\n        }\n        if (/[\\])}]/.test(str[0])) {\n          str = str[0]\n          re.lastIndex = match.index + 1\n        }\n      }\n\n      switch (str) {\n        case '[':\n        case '(':\n        case '{':\n          stack.push(str === '[' ? ']' : str === '(' ? ')' : '}')\n          break\n\n        case ')':\n        case ']':\n        case '}':\n          ch = stack.pop()\n          if (ch !== str) throw new Error(`Expected '${ch}' but got '${str}'`)\n          break\n\n        case '`':\n          re.lastIndex = this.skipES6str(code, end, stack)\n          break\n\n        case '/':\n          re.lastIndex = this.skipRegex(code, end)\n          break\n\n        default:  // quoted string, just skip\n          // except inside ES6TL (like the second quote in `\"${x}\"`)\n          if (stack[stack.length - 1] === 1) {\n            re.lastIndex = match.index + 1  // only skip the first quote\n          }\n          break\n      }\n    }\n\n    return null\n  },\n\n  /*\n    Here we extract the regexes\n  */\n  skipRegex,\n\n  /**\n   * Simple ES6 Template Literal parser, it searches the next back-quote that\n   * signals the end of the ES6TL or the `${` sequence that starts a JS expression,\n   * skipping any escaped character.\n   *\n   * @param   {string} code  - Whole code\n   * @param   {number} start - The start position of the template\n   * @param   {number} stack - To save nested ES6 TL count\n   * @returns {number}         The end of the string (-1 if not found)\n   */\n  skipES6str(code, start, stack) {\n\n    // waiting the ES6TL end?\n    if (stack.length && stack[stack.length - 1] === 1) {\n      stack.pop()\n      return start\n    }\n\n    // we are in the char following the back-tick (`),\n    // find the next unescaped back-tick or the sequence \"${\"\n    const re = /[`$\\\\]/g\n\n    re.lastIndex = start\n    while (re.exec(code)) {\n      const end = re.lastIndex\n      const c = code[end - 1]\n\n      if (c === '`') {\n        return end\n      }\n      if (c === '$' && code[end] === '{') {\n        stack.push(1, '}')\n        return end + 1\n      }\n      // else this is a scape char\n    }\n\n    throw new Error('Unclosed ES6 template')\n  },\n\n  // Makes an optimal regex that matches brackets and backquotes.\n  _reChar(c) {\n    let s\n    if (c.length === 1) {\n      if (/[\\{}[\\]()]/.test(c)) c = ''\n      else if (c === '-') c = `\\\\${c}`\n      s = '[`' + c + '/\\\\{}[\\\\]()]'\n    } else {\n      s = c.replace(/(?=[[^()\\-*+?.$|])/g, '\\\\') + '|[`/\\\\{}[\\\\]()]'\n    }\n    return s\n  }\n}\n\nexport default function extractExpr(options) {\n  return new ExprExtractor(options).parse\n}\n","/**\n * @module TagParser\n * @version v$_VERSION\n */\n\nimport assign from './utils/assign'\nimport extractExpr from './extract-expr'\n//#if !_T\nimport $_T from './node-types'\n//#endif\n\n/**\n * Matches the start of valid tags names; used with the first 2 chars after the `'<'`.\n */\nconst TAG_2C = /^(?:\\/[a-zA-Z>]|[a-zA-Z][^\\s>/]?)/\n\n/**\n * Matches valid tags names AFTER the validation with `TAG_2C`.\n * $1: tag name including any `'/'`, $2: non self-closing brace (`>`) w/o attributes.\n */\nconst TAG_NAME = /\\/(>)|(\\/?[^\\s>/]+)\\s*(>)?/g\n\n/**\n * Matches an attribute name-value pair (both can be empty).\n * $1: attribute name, $2: value including any quotes.\n */\nconst ATTR_START = /(\\S[^>/=\\s]*)(?:\\s*=\\s*([^>/])?)?/g\n\n/**\n * Matches the closing tag of a `script` and `style` block.\n * Used by parseText fo find the end of the block.\n */\nconst RE_SCRYLE = {\n  script: /<\\/script\\s*>/gi,\n  style: /<\\/style\\s*>/gi,\n}\n\n\n// The TagParser class ===============================================\n\nfunction TagParser(options) {\n\n  this.options = assign({\n    comments: false,\n    brackets: ['{', '}']\n  }, options)\n\n  this.extractExpr = extractExpr(this.options)\n  this.parse = this._parse.bind(this)\n  this._re = {}\n}\n\n\n// TagParser methods and properties ==================================\n\nassign(TagParser.prototype, {\n\n  nodeTypes: {\n    TAG:      $_T.TAG,          // ELEMENT_NODE (tag)\n    ATTR:     $_T.ATTR,         // ATTRIBUTE_NODE (attribute)\n    TEXT:     $_T.TEXT,         // TEXT_NODE (#text)\n    COMMENT:  $_T.COMMENT,      // COMMENT_NODE (#comment)\n    EXPR:     $_T.EXPR          // DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC (riot)\n  },\n\n  /**\n   * It creates a raw output of pseudo-nodes with one of three different types,\n   * all of them having a start/end information.\n   * (`end` points to the character following the node).\n   *\n   * TAG     -- has `name` (ex. \"div\" or \"/div\"), `selfclose`, and `attributes`.\n   * TEXT    -- can have an `expr` property in addition to start/end.\n   * COMMENT -- has no props other than start/end.\n   *\n   * `TAG.attributes` is an array of objects with `name`, `value` and `expressions` props.\n   *\n   * `expressions` is an array of objects with start/end properties, relative to the\n   * whole buffer.\n   *\n   * @param   {string} data - html markup\n   * @returns {object} Result, contains data, output\n   */\n  _parse(data) {\n\n    // Creating the state in the closure and passing it as a parameter is more\n    // efficient and allows to use the same parser instance asynchronously.\n    const state = {\n      pos: 0,                 // parsing position\n      last: null,             // current open tag\n      count: -1,              // count of nested tags with the name as root\n      output: []              // array of pseudo-nodes\n    }\n\n    const length = data.length\n    let type = $_T.TEXT\n\n    // The \"count\" property is set to 1 when the first tag is found.\n    // This becomes the root and precedent text or comments are discarded.\n    // So, at the end of the parsing count must be zero.\n\n    while (state.pos < length && state.count) {\n\n      if (type === $_T.TEXT) {\n        type = this.text(state, data)\n\n      } else if (type === $_T.TAG) {\n        type = this.tag(state, data)\n\n      } else if (type === $_T.ATTR) {\n        type = this.attr(state, data)\n\n      }\n    }\n\n    if (state.count) {\n      this._err(state, data, ~state.count ? 'Unexpected end of file.' : 'Root tag not found.')\n    }\n\n    return { data, output: state.output }\n  },\n\n  /**\n   * Custom error handler can be implemented replacing this method.\n   * The `state` object includes the buffer (`data`)\n   * The error position (`loc`) contains line (base 1) and col (base 0).\n   *\n   * @param   {object} state    - Current parser state\n   * @param   {object} loc      - Line and column of the error\n   * @param   {string} message  - Error message\n   */\n  error(state, loc, message) {\n    throw new Error(`[${loc.line},${loc.col}]: ${message}`)\n  },\n\n  /**\n   * On error translates the current position to line, col and calls the\n   * error method of the class.\n   *\n   * @param   {object} state - Current parser state\n   * @param   {string} data  - Processing buffer\n   * @param   {string} msg   - Error message\n   * @param   {number} [pos] - Error position\n   * @private\n  */\n  _err(state, data, msg, pos) {\n    if (pos == null) pos = state.pos\n\n    // count unix/mac/win eols\n    const line = (data.slice(0, pos).match(/\\r\\n?|\\n/g) || '').length + 1\n\n    let col = 0\n    while (--pos >= 0 && !/[\\r\\n]/.test(data[pos])) {\n      ++col\n    }\n\n    state.data = data\n    this.error(state, { line, col }, msg)\n  },\n\n  /**\n   * Creates regex for the given string and the left bracket.\n   *\n   * @param   {string} str - String to add\n   * @returns {RegExp} The resulting regex.\n   * @private\n   */\n  _b0re(str) {\n    let re = this._re[str]\n    if (!re) {\n      const b0 = this.options.brackets[0].replace(/(?=[[^()\\-*+?.$|])/g, '\\\\')\n      this._re[str] = re = new RegExp(`${str}|${b0}`, 'g')\n    }\n    return re\n  },\n\n  /**\n   * @param   {number}      type  - Numeric node type\n   * @param   {string|null} name  - The node name, if null the node has no `name` property\n   * @param   {number}      start - Start pos. For tags, this will point to '<'\n   * @param   {number}      end   - End of this node. In tags this will point to the char\n   *                                following the '>', in text nodes to the char afther\n   *                                the text, so this is mustly the `re.lastIndex` value\n   * @returns {object} A new node.\n   */\n  newNode(type, name, start, end) {\n    const node = { type, start, end }\n\n    if (name) {\n      node.name = name\n    }\n\n    return node\n  },\n\n  /**\n   * Stores a comment.\n   *\n   * @param   {Object}  state - Current parser state\n   * @param   {number}  start - Start position of the tag\n   * @param   {number}  end   - Ending position (last char of the tag)\n   */\n  pushComment(state, start, end) {\n    state.last = null\n    state.pos  = end\n    if (this.options.comments) {\n      state.output.push(this.newNode($_T.COMMENT, null, start, end))\n    }\n  },\n\n  /**\n   * Stores text in the last text node, or creates a new one if needed.\n   *\n   * @param   {Object}  state  - Current parser state\n   * @param   {number}  start  - Start position of the tag\n   * @param   {number}  end    - Ending position (last char of the tag)\n   * @param   {Array}   [expr] - Found expressions\n   * @param   {string}  [rep]  - Escaped brackets to replace\n   */\n  pushText(state, start, end, expr, rep) {\n    let q = state.last\n\n    state.pos = end\n\n    if (q && q.type === $_T.TEXT) {\n      q.end = end\n    } else {\n      state.last = q = this.newNode($_T.TEXT, null, start, end)\n      state.output.push(q)\n    }\n\n    if (expr && expr.length) {\n      q.expressions = q.expressions ? q.expressions.concat(expr) : expr\n    }\n\n    if (rep) {\n      q.replace = rep\n    }\n  },\n\n  /**\n   * Pushes a new *tag* and set `last` to this, so any attributes\n   * will be included on this and shifts the `end`.\n   *\n   * @param   {object}  state - Current parser state\n   * @param   {object}  type  - Like nodeType\n   * @param   {object}  name  - Name of the node including any slash\n   * @param   {number}  start - Start position of the tag\n   * @param   {number}  end   - Ending position (last char of the tag + 1)\n   */\n  pushTag(state, type, name, start, end) {\n    const root = state.root\n    const last = state.last = this.newNode(type, name, start, end)\n\n    state.pos = end\n\n    if (root) {\n      if (name === root.name) {\n        state.count++\n      } else if (name === root.close) {\n        state.count--\n      }\n    } else {\n      // start with root (keep ref to output)\n      state.root  = { name: last.name, close: `/${name}` }\n      state.count = 1\n      state.output.length  = 0\n    }\n\n    state.output.push(last)\n  },\n\n  /**\n   * Pushes a new attribute and shifts the `end` position of the tag (`last`).\n   *\n   * @param   {Object}  state - Current parser state\n   * @param   {Object}  attr  - Attribute\n   */\n  pushAttr(state, attr) {\n    const q = state.last\n\n    //assert(q && q.type === Mode.TAG, 'no previous tag for the attr!')\n    state.pos = q.end = attr.end\n\n    ;(q.attributes || (q.attributes = [])).push(attr)\n  },\n\n  /**\n   * Parse the tag following a '<' character, or delegate to other parser\n   * if an invalid tag name is found.\n   *\n   * @param   {object} state - Parser state\n   * @param   {string} data  - Buffer to parse\n   * @returns {number} New parser mode\n   */\n  tag(state, data) {\n    const pos   = state.pos                 // pos of the char following '<'\n    const start = pos - 1                   // pos of '<'\n    const str   = data.substr(pos, 2)       // first two chars following '<'\n\n    if (str[0] === '!') {                   // doctype, cdata, or comment\n      this.comment(state, data, start)\n\n    } else if (TAG_2C.test(str)) {          // ^\\/?[a-zA-Z]\n      const re = TAG_NAME                   // (\\/?(?:>|[^\\s>/]+)\\s*(>)?) g\n      re.lastIndex = pos\n      const match = re.exec(data)\n      const end   = re.lastIndex\n      const hack  = match[1]\n      const name  = hack ? 'script' : match[2].toLowerCase()  // $1: tag name including any '/'\n\n      // script/style block is parsed as another tag to extract attributes\n      if (name === 'script' || name === 'style') {\n        state.scryle = name         // used by parseText\n        state.hack = hack && RegExp(`<${state.root.close}\\\\s*>`, 'i')\n      }\n\n      this.pushTag(state, $_T.TAG, name, start, end)\n\n      // only '>' can ends the tag here, the '/' is handled in parseAttr\n      if (!hack && match[3] !== '>') {      // $2: non self-closing brace w/o attr\n        return $_T.ATTR\n      }\n\n    } else {\n      this.pushText(state, start, pos)      // pushes the '<' as text\n    }\n\n    return $_T.TEXT\n  },\n\n  /**\n   * Parses comments in long or short form\n   * (any DOCTYPE & CDATA blocks are parsed as comments).\n   *\n   * @param   {object} state - Parser state\n   * @param   {string} data  - Buffer to parse\n   * @param   {number} start - Position of the '<!' sequence\n   */\n  comment(state, data, start) {\n    const pos = start + 2                   // skip '<!'\n    const str = data.substr(pos, 2) === '--' ? '-->' : '>'\n    const end = data.indexOf(str, pos)\n\n    if (end < 0) {\n      this._err(state, data, 'Unclosed comment', start)\n    }\n\n    this.pushComment(state, start, end + str.length)\n  },\n\n  /**\n   * The more complex parsing is for attributes as it can contain quoted or\n   * unquoted values or expressions.\n   *\n   * @param   {object} state - Parser state\n   * @param   {string} data  - Buffer to parse\n   * @returns {number} New parser mode.\n   */\n  attr(state, data) {\n    const tag = state.last                  // the last (current) tag in the output\n    const _CH = /\\S/g                       // matches the first non-space char\n\n    _CH.lastIndex = state.pos               // first char of attribute's name\n    let match = _CH.exec(data)\n\n    if (!match) {\n      state.pos = data.length               // reaching the end of the buffer with\n                                            // $_T.ATTR will generate error\n\n    } else if (match[0] === '>') {\n      // closing char found. If this is a self-closing tag with the name of the\n      // Root tag, we need decrement the counter as we are changing mode.\n      state.pos = tag.end = _CH.lastIndex\n      if (tag.selfclose && state.root.name === tag.name) {\n        state.count--                       // \"pop\" root tag\n      }\n\n      return $_T.TEXT\n\n    } else if (match[0] === '/') {          // self closing tag?\n      state.pos = _CH.lastIndex             // maybe. delegate the validation\n      tag.selfclose = true                  // the next loop\n\n    } else {\n      delete tag.selfclose                  // ensure unmark as selfclosing tag\n      // its a tag, go get the name and the first char of the value (mostly a quote)\n      // we can find no value at all (even if there is an equal sign).\n      const re    = ATTR_START              // (\\S[^>/=\\s]*)(?:\\s*=\\s*([^>/])?)? g\n      const start = re.lastIndex = match.index  // first non-whitespace\n      match       = re.exec(data)\n      const end   = re.lastIndex\n      const value = match[2] || ''          // first letter of value or nothing\n\n      const attr  = { name: match[1].toLowerCase(), value, start, end }\n\n      if (value) {\n        // parse the whole value and get any expressions on it\n        // (parseValue() will modify the `attr` object)\n        this.parseValue(state, data, attr, value, end)\n      }\n\n      this.pushAttr(state, attr)\n    }\n\n    return $_T.ATTR\n  },\n\n  /**\n   * Parses an attribute value for expressions.\n   *\n   * @param   {object} state - Parser state\n   * @param   {string} data  - Whole buffer\n   * @param   {object} attr  - Attribute as {name, value, start, end}\n   * @param   {string} quote - First char of the attribute value\n   * @param   {number} start - Position of the char following the `quote`\n   */\n  parseValue(state, data, attr, quote, start) {\n\n    // Usually, the value's first char (`quote`) is a quote and the `start`\n    // parameter is the stating position of the value.\n    // If not, this is an unquoted value and we need adjust the starting position.\n    if (quote !== '\"' && quote !== \"'\") {\n      quote = ''                            // first char of value is not a quote\n      start--                               // adjust the starting position\n    }\n\n    // Get a regexp that matches the closing quote, ending char of unquoted values,\n    // or the closing brace if we have an expression.\n    const re = this._b0re(`(${quote || '[>/\\\\s]'})`)\n    const expr = []\n    let mm, tmp\n\n    // The only capture in re (closing quote or character) ends the loop\n    re.lastIndex = start\n    while ((mm = re.exec(data)) && !mm[1]) {\n      tmp = this.extractExpr(data, mm.index)\n      if (tmp) {\n        if (typeof tmp == 'string') {\n          attr.replace = tmp                // it is an escaped opening brace\n        } else {\n          expr.push(tmp)\n          re.lastIndex = tmp.end\n        }\n      }\n    }\n\n    if (!mm) {\n      this._err(state, data, 'Unfinished attribute', start)\n    }\n\n    // adjust the bounds of the value and save its content\n    const end = mm.index\n\n    attr.value = data.slice(start, end)\n    attr.valueStart = start\n    attr.end = quote ? end + 1 : end\n\n    if (expr.length) {\n      attr.expressions = expr\n    }\n  },\n\n  /**\n   * Parses regular text and script/style blocks ...scryle for short :-)\n   * (the content of script and style is text as well)\n   *\n   * @param   {object} state - Parser state\n   * @param   {string} data  - Buffer to parse\n   * @returns {number} New parser mode.\n   */\n  text(state, data) {\n    const me = this\n    const pos = state.pos                  // start of the text\n\n    if (state.scryle) {\n      const name = state.scryle\n      const re   = state.hack || RE_SCRYLE[name]\n\n      re.lastIndex = pos\n      const match = re.exec(data)\n      if (!match) {\n        me._err(state, data, `Unclosed \"${name}\" block`, pos - 1)\n      }\n      const start = match.index\n      const end   = state.hack ? start : re.lastIndex\n\n      state.hack = state.scryle = 0         // reset the script/style flag now\n\n      // write the tag content, if any\n      if (start > pos) {\n        me.pushText(state, pos, start)\n      }\n\n      // now the closing tag, either </script> or </style>\n      me.pushTag(state, $_T.TAG, `/${name}`, start, end)\n\n    } else if (data[pos] === '<') {\n      state.pos++\n\n      return $_T.TAG\n\n    } else {\n      const re = me._b0re('<')\n      let mm\n      let expr\n      let rep\n\n      re.lastIndex = pos\n      while ((mm = re.exec(data)) && mm[0] !== '<') {\n        const tmp = me.extractExpr(data, mm.index)\n\n        if (tmp) {\n          if (typeof tmp == 'string') {\n            rep = tmp\n          } else {\n            (expr || (expr = [])).push(tmp)\n            re.lastIndex = tmp.end\n          }\n        }\n      }\n\n      // if no '<' found, all remaining is text\n      const end = mm ? mm.index : data.length\n      me.pushText(state, pos, end, expr, rep)\n    }\n\n    return $_T.TEXT\n  }\n\n})\n\nexport default function tagParser(options) {\n  return new TagParser(options)\n}\n"],"names":["const","let","this","re","end"],"mappings":"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"}